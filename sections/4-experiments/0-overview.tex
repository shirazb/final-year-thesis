In this chapter, I will present and evaluate the results of my experiments.
I will show the compute-memory tradeoff that checkpointing provides; profile the execution time of the solver to evaluate its practicality; and demonstrate the efficiacy of generalising to arbitrary per-operator costs by measuring the effect of checkpointing when assuming uniform costs, profiling only memory, profiling only compute, and when profiling both memory and compute.
